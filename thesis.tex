\documentclass[a4paper,11pt,twoside,openany]{book}

\usepackage{tipx}
\usepackage{algo}
% \usepackage[named]{libtex/algo}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amssymb}
\usepackage{amsthm}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{epsfig}
\usepackage{multirow}
\usepackage{amsfonts,amsmath}
\usepackage{srcltx}
\usepackage{multirow}
\usepackage{dsfont}
\usepackage{booktabs}
\usepackage[countmax]{subfloat}
\usepackage{subcaption}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tabularx}
% \usepackage{subfig}
\usepackage{url}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{libtex/thesisStyle}
\usepackage{float}
\usepackage{enumitem} % To control list spacing





%%%%%%%%%%%%%
\input{libtex/procs}
\input{libtex/alias}
%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%Theorems%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]

%%%%%%%%%%%%%%%%%%%%%%%Colors%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\rb}[1]{{\color{red} #1}\normalcolor}
\newcommand{\bl}[1]{{\color{blue} #1}\normalcolor}
\newcommand{\tl}[1]{{\color{teal} #1}\normalcolor}
\newcommand{\br}[1]{{\color{brown} #1}\normalcolor}

\newcommand{\CAS}{\mbox{\textit{CAS}}}
\newcommand{\FAI}{\mbox{\textit{FAI}}}
\newcommand{\NULL}{\mbox{\sc null}}
\newcommand{\True}{\mbox{\texttt{True}}}
\newcommand{\False}{\mbox{\texttt{False}}}
\newcommand{\Boolean}{\mbox{boolean}}
\newcommand{\Int}{\mbox{int}}

\newcommand{\Process}{\mbox{\sc Process}}
\newcommand{\Insert}{\mbox{\sc Insert}}
\newcommand{\TreeInsert}{\mbox{\sc TreeInsert}}
\newcommand{\RPQHeapInsert}{\mbox{\sc RHeapInsert}}
\newcommand{\RPQHeapDeleteMin}{\mbox{\sc RHeapDeleteMin}}
\newcommand{\PQSAInsert}{\mbox{\sc InsertSA}}
\newcommand{\PQSADeleteMin}{\mbox{\sc DeleteMinSA}}
\newcommand{\SBInsert}{\mbox{\sc SBInsert}}
\newcommand{\MBInsert}{\mbox{\sc MBInsert}}
\newcommand{\Put}{\mbox{\sc Put}}
\newcommand{\Transform}{\mbox{\sc Transform}}
\newcommand{\Delete}{\mbox{\sc Delete}}
\newcommand{\Search}{\mbox{\sc Search}}
\newcommand{\Traverse}{\mbox{\sc Traverse}}
\newcommand{\Clean}{\mbox{\sc Clean}}
\newcommand{\SplitLeaf}{\mbox{\sc SplitLeaf}}
\newcommand{\DeleteMin}{\mbox{\sc DeleteMin}}
\newcommand{\GetMin}{\mbox{\sc GetMinHeap}}
\newcommand{\InitDeletePhaseHeap}{\mbox{\sc InitDeletePhaseHeap}}
\newcommand{\InitDeletePhaseSA}{\mbox{\sc InitDeletePhaseSA}}
\newcommand{\InitDeletePhase}{\mbox{\sc InitDeletePhase}}
\newcommand{\HeapDeleteMin}{\mbox{\sc DeleteMinHeap}}
\newcommand{\DeleteMinSA}{\mbox{\sc DeleteMinSA}}
\newcommand{\BufferCreation}{\mbox{\sc BufferCreation}}
\newcommand{\TreePopulation}{\mbox{\sc TreePopulation}}
\newcommand{\Prunning}{\mbox{\sc Prunning}}
\newcommand{\Refinement}{\mbox{\sc Refinement}}
\newcommand{\QueryAnswering}{\mbox{\sc QueryAnswering}}
\newcommand{\UpdateBSF}{\mbox{\sc UpdateBSF}}
\newcommand{\FindNode}{\mbox{\sc FindNode}}
\newcommand{\TotalNodes}{\mbox{\sc TotalNodes}}
\newcommand{\HelpTree}{\mbox{\sc HelpTree}}
\newcommand{\NextIndex}{\mbox{\sc NextIndex}}
\newcommand{\BC}{\mbox{$\mathit{BC}$}}
\newcommand{\PS}{\mbox{$\mathit{PS}$}}
\newcommand{\RS}{\mbox{$\mathit{RS}$}}
\newcommand{\RawData}{\mbox{$\mathit{RawData}$}}
\newcommand{\Refresh}{\mbox{$\mathit{ReFreSh}$}}
\newcommand{\Fresh}{\mbox{$\mathit{FreSh}$}}
\newcommand{\MESSI}{\mbox{$\mathit{MESSI}$}}
\newcommand{\MESSIenh}{\mbox{$\mathit{MESSIenh}$}}
%BASELINES
\newcommand{\DoAll}{\mbox{\sf DoAll}}
\newcommand{\FI}{\mbox{\sf FI-Based}}
\newcommand{\FINoSum}{\mbox{\sf FI-Based-NoSum}}
\newcommand{\DoAllSplit}{\mbox{\sf DoAll-Split}}
\newcommand{\DoAllSplitNoSum}{\mbox{\sf DoAll-Split-NoSum}}
\newcommand{\CASBased}{\mbox{\sf CAS-Based}}
%Evaluation
\newcommand{\FreshSub}{\mbox{Subtree}}
\newcommand{\FreshSTD}{\mbox{Standard}}
\newcommand{\FreshTreeCopy}{\mbox{TreeCopy}}
%CLEAN
\newcommand{\TPCLEAN}{\mbox{$\mathit{TP.CLEAN}$}}



% FOR WRITING GREEK %
\usepackage[greek,american]{babel}
\usepackage[libtex/iso-8859-7]{inputenc}

\newcommand{\selg}[0]{\selectlanguage{greek}}
\newcommand{\selam}[0]{\selectlanguage{american}}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%\renewcommand{\baselinestretch}{1.5}
%\textheight=23cm \textwidth=16cm \voffset -1.5cm \hoffset -12.8mm
%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\baselinestretch}{1}\small\normalsize
\textwidth=390pt \oddsidemargin = 50pt \evensidemargin = 0pt
%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeindex

\thispagestyle{empty}
\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%
\long\def\symbolfootnote[#1]#2
    {\begingroup
    \def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}
    \endgroup}

\newcommand{\workperformedat}{\symbolfootnote[0]{This work has been
    performed at the University of Crete, School of Sciences and
Engineering, Computer Science Department.}}

\newcommand{\worksupportedby}{\symbolfootnote[0]{The work has been
    supported by the Foundation for Research and Technology - Hellas (FORTH),
    Institute of Computer Science (ICS).}}

\newcommand{\thesisdate}{March 2025 }
%%%%%%%%%%%%%%%%%%%%%%%%%%


\overfullrule=5pt

\setlength{\baselineskip}{6pt}
\setlength{\itemsep}{0pt} % Reduce space between list items


\begin{document}
\begin{titlepage}
\begin{center}

\LARGE \textbf{DFreSh: A Lock-Free Index for Real-Time Data Series Processing}\\[0.5cm]
\LARGE \textit{Paterakis George}\\[0.5cm]

\vfill

\normalsize{
Thesis submitted in partial fulfillment of the requirements for the\\[0.30cm]

\textit{Masters' of Science degree in Computer Science and Engineering}}\\[0.30cm]

University of Crete\\
School of Sciences and Engineering\\
Computer Science Department\\
Voutes University Campus, 700 13 Heraklion, Crete, Greece\\[0.5cm]

\vfill

\Large{Thesis Advisor: Assistant Prof. \emph{Panagiota Fatourou}}\\[0.5cm]

\vfill

\end{center}

\workperformedat{} \worksupportedby{}
\end{titlepage}

\cleardoublepage





\thispagestyle{empty}

\newcommand{\thesistitle}{Lock-Free Indexes For Data Series Processing}
\newcommand{\owner}{Paterakis George}
\newcommand{\firstprof}{Panagiota Fatourou}
\newcommand{\secondprof}{Themis Palpanas}
\newcommand{\thirdprof}{Kostas Magoutis}
\newcommand{\csdchair}{Kostas Magoutis}

\begin{titlepage}

\begin{center}
\textsc{University of Crete}\\
\textsc{Computer Science Department}\\
\vspace{0.4cm}
\noindent {\textbf{\thesistitle{}}}\\
\vspace{0.4cm}
\noindent Thesis submitted by\\
\textbf{\owner{}}\\
in partial fulfillment of the requirements for the\\
Masters' of Science degree in Computer Science\\
\vspace{0.4cm} THESIS APPROVAL

\vspace{0.4cm}

\begin{tabular}{rl}
\\
Author: & \underline{\phantom{123456789012345678901234567890123456789012}}\\
    & \owner{}\\
    \\
    \\
    \\
Committee approvals: & \underline{\phantom{123456789012345678901234567890123456789012}}\\
    & \firstprof{}\\
    & {\small Assistant Professor, Thesis Supervisor}\\
    \vspace{0.2cm}
    \\
    \\
& \underline{\phantom{123456789012345678901234567890123456789012}}\\
    & \secondprof{}\\
    & {\small Professor, Committee Member}\\
    \vspace{0.2cm}
    \\
    \\
& \underline{\phantom{123456789012345678901234567890123456789012}}\\
    & \thirdprof{}\\
    & {\small  Professor, Committee Member}\\
    \vspace{0.2cm}
    \\
    \\
\hspace{1.4ex}Departmental approval: & \underline{\phantom{123456789012345678901234567890123456789012}}\\
    & \csdchair{}\\
    & {\small Professor, Director of Graduate Studies}\\
\end{tabular}
\\

\vfill Heraklion, \thesisdate{}
\end{center}

\thispagestyle{empty}

\end{titlepage}

\cleardoublepage








\thispagestyle{empty}
\begin{titlepage}
\begin{center}
\bc \Large{ \textbf{Lock-Free Indexes For Data Series Processing}} \ec \bc {\bf\large Abstract}\\\ec
\end{center}

In this thesis, we study lock-free data series indexes that achieve high performance
while maintaining robustness. First, we present FreSh, a lock-free data series index
based on Refresh, a generic approach we developed for efficiently supporting
lock-freedom on top of any locality-aware data series index.
We believe Refresh is of independent interest and can be used to derive 
high-performance lock-free versions of other locality-aware blocking data structures.
% 
To develop FreSh, we first conducted an in-depth study of the design decisions 
behind state-of-the-art data series indexes and the principles governing their 
performance. This led to a theoretical framework that enables the modular development 
and analysis of data series indexes. FreSh is designed for static data.
Experiments with several synthetic and real datasets illustrate that FreSh 
achieves performance comparable to that of the state-of-the-art blocking 
in-memory data series indexes. This demonstrates that the helping mechanisms of FreSh 
are lightweight and respect key principles that are crucial for performance 
in locality-aware data structures.
% \textsuperscript{*}
% 
A second contribution of this thesis is an extension of FreSh that works
in dynamic settings, which we call DFreSh. DFreSh handles batches of data that arrive
in the system dynamically, making it a robust solution for real-time applications while
retaining the performance benefits of FreSh. We follow two models of dynamicity coming
from two research fields and study the performance properties of each of these settings
using several synthetic and real datasets.




\vspace{1em}
\begin{center}
    \textsuperscript{*}\textit{FreSh has been published in the 42nd International \textbf{Symposium on Reliable Distributed Systems}, 2023.}
\end{center}
\vspace{1em}

\vfill
\end{titlepage}


\selam

\pagestyle{plain}
\pagenumbering{roman}
\setcounter{page}{1}
\setcounter{tocdepth}{3}

\tableofcontents

%\listoftables
%     \addtocontents{toc}{\contentsline {chapter}{List of Tables}{iii}}

% \listoffigures
%     \addtocontents{toc}{\contentsline {chapter}{List of Figures}{v}}

% \cleardoublepage

\pagenumbering{arabic}
%\renewcommand*\thesection{\arabic{section}}




 \pagestyle{headings}
%%%%%%%%%%%%%%%%%%%%%%% Introduction   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include{src/introduction}
%%%%%%%%%%%%%%%%%%%%%%% PRELIMINARIES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include{src/preliminaries}
%%%%%%%%%%%%%%%%%%%%%%% Traverse Object %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include{src/traverse-object}
%%%%%%%%%%%%%%%%%%%%%%% Locality Awareness %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include{src/locality}
%%%%%%%%%%%%%%%%%%%%%%% FreSh %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include{src/fresh}
    
\subsection{FreSh with Dynamic Batches}


\begin{algorithm}[t]
    \footnotesize
    \caption{Type Definitions for TreeInsertion with Dynamic Batches}
    \label{alg:tree-types-dynamic}
    \begin{algorithmic}[1]
        \Statex \textbf{Type Definitions:}
        \State \textbf{Type} Node:
        \State \quad int $\mathit{key}$
        \State \quad $\{Node,Leaf\}$ *$\mathit{left}$
        \State \quad $\{Node,Leaf\}$ *$\mathit{right}$
        \State \quad InsertRec $\mathit{Announce}[0..n-1]$
        \State \quad \textbf{Int} $\mathit{helpersExist}$

        \Statex
        \State \textbf{Type} InsertRec:
        \State \quad Data $\mathit{data}$
        \State \quad int $\mathit{position}$

        \Statex
        \State \textbf{Type} Leaf \textbf{extends} Node:
        \State \quad DynamicData $D[0..m-1]$
        \State \quad CounterObject Elements

        \Statex
        \State \textbf{Type} DynamicData \textbf{extends} Data:
        \State \quad int $\mathit{seq}$

    \end{algorithmic}
\end{algorithm}


\begin{algorithm}[t]
    \footnotesize
    \caption{DTraverseTree: a lock-free leaf-oriented tree with fat leaves, implementing a traverse object
    for dynamic batches. Code for thread $t \in \{0, \ldots, n-1\}$.}
    \label{alg:tree:dynamic}
    \begin{algorithmic}[1]

        \State \textbf{Shared variables:}
        \State \{Node,Leaf\} *$Tree$ :=  $\NULL$, initially pointing to a Leaf:
        \Statex \quad $\langle \mathit{key}, \NULL, \NULL, \langle \langle \bot, \bot \rangle, \ldots, \langle \bot, \bot \rangle \rangle,\False, \langle \bot, \ldots, \bot \rangle, \bot, 0 \rangle$

        \Function{TreeInsert}{$\mathit{data}, \mathit{isHelper}, \mathit{mode}, \mathit{batchID}$}
            \State Leaf *$\mathit{leaf}$
            \State \{Node,Leaf\} *$\mathit{parent}$ := $Tree$, **$ptr$
            \State int $\mathit{pos}, \mathit{val}$
            \State Boolean $\mathit{expeditive}$ \label{alg:tree:isHelper_dynamic}

            \While{\True} \label{alg:tree:while_dynamic}
                \State $\langle \mathit{leaf, parent} \rangle $ := $ \Search(\mathit{data, parent})$ \label{alg:tree:search:dynamic}
                \If{$\mathit{parent} = \NULL$} 
                    \State $ptr $ := $ \&Tree$ \label{alg:tree:ptr-null}
                \ElsIf{$\mathit{parent \rightarrow left = leaf}$} 
                    \State $ptr $ := $ \&\mathit{parent \rightarrow left}$
                \Else 
                    \State $ptr $ := $ \&\mathit{parent \rightarrow right}$ \label{alg:tree:ptr-right_dynamic}
                \EndIf

                \bl{
                \If{$\mathit{isHelper} = \True$ \textbf{and} $\mathit{leaf \rightarrow helpersExist \leq currentUpdate}$} \label{alg:tree:require-switch-mode_dynamic}
                    \State \Int\ tmp := $ \mathit{leaf \rightarrow helpersExist}$
                    \If{$\mathit{tmp == leaf \rightarrow helpersExist}$ \textbf{and} $\mathit{tmp \leq currentUpdate}$}
                        \State $\mathit{CAS(\&leaf \rightarrow helpersExist, currUpdate, currUpdate+1)}$
                    \EndIf
                \EndIf
                }

                \State $\mathit{\langle pos, expeditive \rangle} $ := $ \mathit{Elements.NextIndex(\&leaf \rightarrow helpersExist)}$ \label{alg:tree:object-pos_dynamic}
                
                \If{$\mathit{expeditive} = \False$} 
                    \State $\mathit{leaf \rightarrow Announce[t]} $ := $ \langle \mathit{data, \bot} \rangle$ \label{alg:tree:announce-op_dynamic}
                \EndIf

                \If{$\mathit{pos < M}$} \label{alg:tree:pos-in-D_dynamic}
                    
                    \If{$\mathit{expeditive = \False}$}
                        \State $\mathit{leaf \rightarrow Announce[t].position} $ := $ \mathit{pos}$ \label{alg:tree:pos-in-D:update_dynamic}
                    \EndIf
                    \If{\br{ $\mathit{Elements.GetIndex} \leq M$ \textbf{and} $\mathit{mode} = \mathit{LOGICAL}$}}
                        \State \br{$\mathit{CAS(\&leaf \rightarrow D[pos].seq, \bot, MARKED)}$} \label{alg:tree:store-marked}
                    \EndIf
                    \State $\mathit{leaf \rightarrow D[pos]} $ := $ \mathit{data}$ \label{alg:tree:store-in-D_dynamic}

                    
                    \If{\br{$\mathit{mode == LOGICAL}$}} \label{alg:tree:store-timestamp-start}
                        \If{\br{$\mathit{leaf \rightarrow D[pos].seq == \bot }$}} \label{alg:tree:store-timestamp:opt}
                            \State \br{\Int\ currSeq := GlobalSeq}
                            \State \br{$\mathit{CAS(\&leaf \rightarrow D[pos].seq, \bot, currSeq)}$} \label{alg:tree:store-timestamp-CAS}
                        \EndIf
                    
                    \ElsIf{\tl{$\mathit{mode == SYSTEM}$}}
                        \State \tl{$\mathit{leaf \rightarrow D[pos].seq} $ := $ \mathit{timeStamp[batchID]}$}
                    \EndIf \label{alg:tree:store-timestamp-end}
                \Else
                    \State \SplitLeaf($\mathit{leaf}, \mathit{ptr}, \mathit{expeditive}$) \label{alg:tree:pos-not-in-D_dynamic}
                \EndIf

                
                \If{\bl{$($*$ptr$) $\rightarrow helpersExist = currentUpdate+1$}} \label{alg:tree:st:finish_dynamic}
                    \If{$expeditive = \False$ \textbf{and} $($*$ptr$) $\rightarrow Announce[t].position \neq \bot$} \label{alg:tree:op-is-applied_dynamic}
                        \State $($*$ptr$) $\rightarrow Announce[t] $ := $ \langle \bot, \bot \rangle$ \label{alg:tree:clean_dynamic}
                    \Else
                        \State \textbf{continue} \label{alg:tree:re-attempt_dynamic}
                    \EndIf
                \EndIf

                \Return
            \EndWhile
        \EndFunction

    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[t]
    \footnotesize
    \begin{algorithmic}[1]
        \Procedure{SplitLeaf}{$\mathit{leaf}$, $\mathit{prt}$, $\mathit{expeditive}$, $\mathit{mode}$}
            \State $\mathit{newNode} $ :=  \textbf{new} Node initialized with $\langle \bot, \NULL,
             \NULL, \langle \langle \bot, \bot \rangle, \ldots, \langle \bot, \bot \rangle \rangle, \textbf{not} \mathit{expeditive} \rangle$ \label{alg:tree:split:new-internal-node-dynamic}
            \State $\mathit{newNode \rightarrow left}$ := \textbf{new} Leaf initialized with 
            \Statex $\langle \bot, \NULL, \NULL, \langle \langle \bot, \bot \rangle, \ldots, \langle \bot, \bot \rangle \rangle,\False, \langle \bot, \ldots, \bot \rangle, \bot, 0 \rangle$ \label{alg:tree:split:new-lc-dynamic}
            \State $\mathit{newNode \rightarrow right}$ := \textbf{new} Leaf initialized similarly \label{alg:tree:split:new-rc-dynamic}
            \State $\mathit{splitBuffer} $ := $\emptyset$
            
            \If{$\mathit{expeditive = \False}$} \label{alg:tree:em:Announce-scan-dynamic}
                \For{$i \in \{0, \ldots, n-1\}$ \textbf{with} $\mathit{leaf \rightarrow Announce[i].data} \neq \bot$} \label{alg:tree:Announce-scan-dynamic}
                    \State $\mathit{ldata} $ := $ \mathit{leaf \rightarrow Announce[i].data}$
                    \If{$\mathit{leaf \rightarrow Announce[i].position} \neq \bot$} \label{alg:tree:announce-scan:pos-not-bot-dynamic}
                        \State $\mathit{pos} $ := $ \mathit{leaf \rightarrow Announce[i].position}$
                        \State $\mathit{leaf \rightarrow D[\mathit{pos}].data} $ := $ \mathit{ldata}$ \label{alg:tree:announce-scan:store-in-D-dynamic}
                        
                        \If{\br{$\mathit{mode == LOGICAL}$}}
                            \If{\br{$\mathit{leaf \rightarrow D[\mathit{pos}].seq == MARKED}$}}
                                \State \br{$\mathit{CAS(\&leaf \rightarrow D[\mathit{pos}].seq, MARKED, \bot)}$}
                            \Else
                                \State \br{$\mathit{tmstamp} $ := $ \mathit{TIMESTAMP}$}
                                \If{\br{$\mathit{leaf \rightarrow D[\mathit{pos}].seq == \bot}$}}
                                    \State \br{$\mathit{CAS(\&leaf \rightarrow D[\mathit{pos}].seq, \bot,tmstamp )}$}
                                \EndIf
                            \EndIf
                        \ElsIf{\tl{$\mathit{mode == SYSTEM}$}}
                            \State \tl{$\mathit{tmstamp} $ := $ \mathit{timeStamp[batchID]}$}
                            \State \tl{$\mathit{leaf \rightarrow D[\mathit{pos}].seq} $ := $ \mathit{tmstamp}$}
                        \EndIf
                    \Else
                        \If{\br{$\mathit{mode == LOGICAL}$}}
                            \State \br{\textbf{Add} $(\mathit{ldata,\bot})$ \textbf{to} $\mathit{splitBuffer}$}
                        \Else
                            \State \tl{\textbf{Add} $(\mathit{ldata,timeStamp[batchID]})$ \textbf{to} $\mathit{splitBuffer}$}
                        \EndIf
                    \EndIf \label{alg:tree:announce-scan:data-copy-dynamic}
                    \State $\mathit{newNode \rightarrow Announce[i]} $ := $ \langle \mathit{ldata}, -1 \rangle$ \label{alg:tree:announce-scan:mark-op-applied-dynamic}
                \EndFor
            \EndIf \label{alg:tree-split-set-timestamp-start}
            
            \For{\textbf{each} element in $\mathit{leaf \rightarrow D[i]} \cup \mathit{splitBuffer}$}
                \If{\bl{$\mathit{element.seq == \bot\ \And\ element \in D}$}}
                    \If{\br{$\mathit{mode == LOGICAL}$}}
                        \If{\br{$\mathit{leaf \rightarrow D[\mathit{pos}].seq == MARKED}$}}
                            \State \br{$\mathit{CAS(\&leaf \rightarrow D[\mathit{pos}].seq, MARKED, \bot)}$}
                        \Else
                            \State \br{$\mathit{tmstamp} $ := $ \mathit{TIMESTAMP}$}
                            \If{\br{$\mathit{leaf \rightarrow D[\mathit{pos}].seq == \bot}$}}
                                \State \br{$\mathit{CAS(\&leaf \rightarrow D[\mathit{pos}].seq, \bot,tmstamp )}$}
                            \EndIf
                        \EndIf
                    \ElsIf{\tl{$\mathit{mode == SYSTEM}$}}
                        \State \tl{$\mathit{tmstamp} $ := $ \mathit{timeStamp[batchID]}$}
                        \State \tl{$\mathit{leaf \rightarrow D[\mathit{pos}].seq} $ := $ \mathit{tmstamp}$}
                    \EndIf
                \EndIf
                \State \textbf{Distribute} the element into $\mathit{newNode \rightarrow left}$ \textbf{or} $\mathit{newNode \rightarrow right}$
                \Statex   \textbf{based on its key}
            \EndFor \label{alg:tree-split-set-timestamp-end}
            
            \State \textbf{Fix the key of} $\mathit{newNode}$ \Comment{may result in further leaf splits} \label{alg:tree:split-dynamic}
            \State $\CAS(*\mathit{ptr}, \mathit{leaf}, \mathit{newNode})$ \label{alg:tree:CAS-dynamic}
            
            \If{\br{$\mathit{mode == LOGICAL}$}}
                \State \br{\textbf{Traverse} $\mathit{ptr \rightarrow left}$ \textbf{and} $\mathit{ptr \rightarrow right}$ 
                \Statex \br{\textbf{and for each element with} $\mathit{element.seq == \bot}$}}
                \State \br{\hspace{1em} $\mathit{tmstamp} $ := $ \mathit{TIMESTAMP}$}
                \State \br{\hspace{1em} $\mathit{CAS(\&element.pos.seq, \bot,tmstamp )}$}
            \EndIf
        \EndProcedure
    \end{algorithmic}
    \caption{SplitLeaf with batches: a lock-free split operation for a leaf-oriented tree with fat leaves.
        Code for thread $t \in \{0, \ldots, n-1\}$.}
    \label{alg:tree-split-dynamic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%% Priority Queues %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[t]
    \footnotesize
    \begin{algorithmic}[1]
        \State{Code for thread $p \in \{0, \ldots, n-1\}$}
        \State \textbf{Shared variables:}
        \State $\mathit{\langle int, Data \rangle}$ $A[0..k-1][0...n-1]$, initially all $\langle \bot, \bot \rangle$
        \State CounterObject Cnt, initially $0$
        \State Boolean $\mathit{helpersExist}$, initially \False
        \State int $\mathit{insPos}$, initially $0$
        \State $\mathit{\langle int, Data \rangle}$ *$\mathit{SA}$, initially \NULL
        \State int $\mathit{arrayID}$, initially $p$

        \Procedure{Insert}{$\mathit{priority}$, $\mathit{values}$}
            \State Append $\mathit{values}$ at $\mathit{A[arrayID][p]}$ \label{alg:pq:ins:store:dynamic}
            \State $\mathit{arrayID := (arrayID+1) \mod k}$
        \EndProcedure

        \Procedure{InitDeletePhase}{}
            \State $\mathit{\langle int, Data \rangle}$ *$\mathit{sa}$
            \For{\textbf{each} $\mathit{array}$ in $\mathit{A[k]}$}
                \If{$\mathit{array}$ has valid data}
                    \State $\mathit{insPos}$ := $\mathit{insPos}$ + array.size
                \EndIf
            \EndFor
            \State $\mathit{sa}$ := allocate local array of $insPos$ elements
            \State copy into $\mathit{sa}$ the non-$\bot$ elements of $A$ and sort them \label{alg:sa:local-copy-dynamic}
            \State $\mathit{CAS(\&SA, \NULL, sa)}$ \label{alg:sa:CAS-dynamic}
        \EndProcedure

        \Procedure{DeleteMin}{Boolean $\mathit{isHelper}$, int $\mathit{CurrentUpdate}$} \textbf{returns} $\mathit{Data}$
            \If{$\mathit{isHelper = \True}$ \textbf{and} $\mathit{helpersExist} \leq \mathit{CurrentUpdate}$}
                \State int tmp := $\mathit{helpersExist}$
                \If{$\mathit{tmp == helpersExist}$ \textbf{and} $\mathit{tmp} \leq \mathit{CurrentUpdate}$}
                    \State $\mathit{CAS(\& helpersExist, CurrentUpdate, CurrentUpdate+1)}$
                \EndIf
            \EndIf
            \State int $\mathit{pos} := \mathit{Cnt.\NextIndex(\&helpersExist})$ \label{alg:pq:ins:FAI-dynamic}
            \If{$\mathit{pos} \geq \mathit{insPos}$}
                \State \Return $\bot$
            \EndIf
            \If{$\mathit{mode == LOGICAL}$}
                \If{$\mathit{SA[pos].data.seq == MARKED}$}
                    \State \Return $\bot$
                \EndIf            
                \If{$\mathit{SA[pos].data.seq == \bot}$}
                    \State int $\mathit{currSeq := GlobalSeq}$
                    \State $\mathit{CAS(\&SA[pos].data.seq, \bot, currSeq)}$ \label{alg:pq:CAS:Dynamic}
                \EndIf
            \EndIf
            \State \Return $\mathit{SA[pos].data}$
        \EndProcedure
    \end{algorithmic}
    \caption{Priority queue of \Fresh with batches.}
    \label{alg:pq-dynamic}
\end{algorithm}

As discussed in previous chapters, we designed and implemented an extension of FreSh,
called \textit{DFreSh}, that supports insertions of dynamic batches while ensuring that
queries always return the best possible answer and respect linearizability.
In the pseudocode provided, we refer to this version as \textit{LOGICAL}.
This approach is completely lock-free, meaning that neither index workers nor query workers
need to wait for each other as long as they have available work. For example, index workers
can continue inserting batches while query workers process queries concurrently.  
% 
To ensure correctness, we need a mechanism that guarantees a query with a
specific timestamp always returns the same result. To achieve this, we introduce 
a sequence number mechanism. Specifically, we maintain a global shared counter,
\textit{GlobalSeq}, which is accessible to both index and query workers.
Query workers read the current value of \textit{GlobalSeq} and attempt to increment it
by one before answering a query. A query must be able to see all data series inserted
into the index with a timestamp smaller than or equal to its own before it is answered.  
%
The insertion process for index workers follows the same general approach as in FreSh,
using the \texttt{TreeInsert} method (see Algorithm~\ref{alg:tree:dynamic}). However,
the iSAX tree structure in this dynamic setting differs from that of FreSh.
Each leaf node now contains an array \( D \), where each element consists of
a sequence number, an iSAX summary, and a pointer to the original data series stored in
\texttt{RawData}. Despite these differences, the core insertion procedure remains
similar to what was described in Chapter~\ref{chapter:FreSh}.  
An index worker first locates the appropriate leaf to insert a new element
(line~\ref{alg:tree:search:dynamic}). It then attempts to acquire a position in the leaf
node. If space is available (line~\ref{alg:tree:pos-in-D_dynamic}), the data series is
stored as before. However, for an element to be considered valid, it must first be assigned
a sequence number, which is done using a Compare-And-Swap (CAS) operation
(line~\ref{alg:tree:store-timestamp-CAS}).  
Since queries are processed concurrently with insertions, a query worker may
encounter elements in a candidate leaf during the \textit{Refinement} stage. For each
element in the leaf, the query worker first checks its sequence number. If the sequence
number is smaller than or equal to the query's timestamp, the element must be considered
in the query result. If it has a larger value, the query worker skips it. However, if the
sequence number is unassigned (denoted by \( \bot \)), the query worker cannot ignore
the element and must help assign a sequence number using a CAS operation
(line~\ref{alg:pq:CAS:Dynamic}). Since both index and query workers can assign sequence
numbers, the CAS operation ensures correctness while the preceding conditional
check optimizes performance by avoiding unnecessary failed CAS attempts.
%
On the other hand, if the leaf is full, the index worker attempts to perform a split.  
During the split operation, the index worker first examines the announce array
for any operations that have been announced but not yet placed into the leaf.
If a thread has announced both the data and its position inside the leaf,
the thread performing the split rewrites the data into that position,
as was done in FreSh. Additionally, if the sequence number is unassigned,
the worker helps assign one. However, if the position has not yet been announced,
the data is temporarily stored in a buffer called \textit{splitBuffer}.  
%
Next, the index worker distributes the elements stored in \textit{splitBuffer},
along with those already in the leaf, to the new left and right child nodes
based on their iSAX summaries. During this process, for elements originally
from the leaf, the worker checks their sequence numbers and assigns one
if necessary. This step is crucial because the leaf remains connected to the
tree, making it visible to query workers, which may have included it in their
query results.  
%
Once all elements are distributed, the worker attempts to finalize the split
using a \CAS operation, following the same approach as in FreSh. However,
to fully complete the split, a traversal of the newly created child nodes
is required. This is because elements moved from the \textit{splitBuffer}
may still have unassigned sequence numbers. Importantly, this traversal must
not be performed before the split is established, as announce arrays are not
visible to query workers. If these elements receive a sequence number smaller
than or equal to that of an ongoing query before the split is finalized,
it could lead to correctness violations.
% 

There is one final scenario that can occur during splitting, which we address
using the keyword \textit{MARKED}. Consider the following case: an index worker
announces its data and acquires a position in the leaf but becomes slow before
announcing the position. Meanwhile, another index worker starts a split operation.
Since the first worker has not yet announced its position, its operation is treated
as incomplete and stored in the \textit{splitBuffer}.  
%
While the split is ongoing, the first worker resumes execution and inserts its element
into the leaf. At this point, the element becomes visible to queries and may receive
a sequence number-either from the inserting thread or from a query worker. This can
lead to a correctness violation because the same element might be assigned different
sequence numbers before and after the delay. If the thread performing the split has
already processed the position where the first worker is placing the element,
it will not include it, meaning the element will only receive a sequence number
when the new child nodes are traversed after the split. If this element happens
to be the best answer for an ongoing query, the query may or may not include it in
its results, violating correctness.  
%
To prevent this issue, we introduce a marking technique. Before storing data into 
the leaf, a thread first checks whether a split is in progress by reading the value
of \textit{NextIndex}. If a split is occurring, the thread marks its position
by setting the sequence number to \textit{MARKED} using a CAS operation before
inserting the data. A query encountering a \textit{MARKED} position treats it as 
invalid. During the split operation, all marked positions are reset to \( \bot \), 
ensuring that these elements receive a sequence number either from a query worker
or when processing the new child nodes after the split.

\include{src/evaluation}





% %BIB
\bibliographystyle{plain}
\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{bib/thesis}



\end{document}
